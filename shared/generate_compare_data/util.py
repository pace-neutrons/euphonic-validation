"""
Helper and utility functions for the scripts in this
directory
"""
import fnmatch
import os
import warnings
from typing import Optional

import numpy as np
import matplotlib.pyplot as plt

from euphonic import ForceConstants, QpointPhononModes, StructureFactor


# Define here so they can be imported from elsewhere too,
# to allow consistent plot styles
line_colours = ['m', 'orange', 'tab:cyan']
line_styles = ['-', '-', '--']
markers = ['o', '+', 'x']
marker_sizes = [4**2, 6**2, 5**2]

latex_mat_names = {'nb': 'Nb',
                   'quartz': 'Quartz',
                   'lzo': '\lzo',
                   'al': 'Al'}
latex_cut_names = {'2ph_m4_0_qe': '[H,-4,0]',
                   '30L_qe_fine': '[-3,0,-L]',
                   'kagome_qe': '[-5,7,-L]',
                   'hh2_qe_fine': '[H,-H,-2]',
                   '110_qe': '[H,H,0]',
                   'm110_qe': '[2-K,K,0]',
                   'h00_qe': '[H,2,2]',
                   'h_0.5kl_qe': '[H,2+0.5H,2+0.5H]'}

def get_material_info(material, ab2tds=False):
    if ab2tds:
        temps = ['300']
    else:
        temps = ['5', '300']
    code = 'castep'
    if material == 'quartz':
        cuts = ['2ph_m4_0_qe', '30L_qe_fine']
        grid = '5,5,4'
    elif material == 'lzo':
        cuts = ['kagome_qe', 'hh2_qe_fine']
        grid = '4,4,4'
    elif material == 'nb':
        cuts = ['110_qe', 'm110_qe']
        grid = '10,10,10'
    elif material == 'al':
        cuts = ['h00_qe', 'h_0.5kl_qe']
        grid = '10,10,10'
        code = 'phonopy'
    else:
        raise ValueError(f'Invalid material {material}')
    return cuts, grid, temps, code


def get_dir(material: str, code: Optional[str] = None,
            cut: Optional[str] = None) -> str:
    """
    Get directory containing files for that material, cut and code
    """
    path = os.path.join('..', '..', material)
    if cut is None:
        cut = 'shared'
    path = os.path.join(path, cut)
    if code is not None:
        path = os.path.join(path, code)
    return path


def get_euphonic_fpath(material: str, code: str, obj: str, temperature: str,
                       cut: Optional[str] = None, **fname_kwargs) -> str:
    """
    Get full path to euphonic .json output file for a particular
    material, code, and cut. See get_euphonic_fname for more arg details
    """
    return os.path.join(
        get_dir(material, code, cut=cut),
        get_euphonic_fname(obj, temperature, code=code, **fname_kwargs))


def get_euphonic_fname(
        obj: str, temperature: str, code: str = 'euphonic',
        from_fc: bool = False, grid: Optional[str] = None,
        reduced: bool = False) -> str:
    """
    Generate Euphonic output .json filenames. These may be for Euphonic
    generated data, or Ab2tds/Oclimax data converted to Euphonic format

    Parameters
    ----------
    obj
        Type of data contained in the file, one of ['dw', 'sf', 'sqw']
        for DebyeWaller, StructureFactor and Spectrum2D containing a
        S(Q, w) map respectively
    temperature
        Temperature used to calculate obj
    code
        Which code obj was generated with, one of ['euphonic',
        'oclimax', 'ab2tds']
    from_fc
        Whether obj was generated by calculating phonon frequencies
        from force constants, or by reading precalculated
        frequencies (e.g. from a .phonon file). Only applicable if
        code='euphonic'
    grid
        Comma-separated MP grid that was used to generate obj e.g.
        '4,4,4'. Only applicable if obj='dw'
    reduced
        Whether obj was generated using a reduced or full MP grid. This
        is applicable for structure factor objs too, as they use
        a Debye-Waller factor that can be full or reduced.
    """
    if not code in ['euphonic', 'ab2tds', 'oclimax']:
        raise ValueError(f'Unrecognised code {code}')
    if not obj in ['dw', 'sf', 'sqw']:
        raise ValueError(f'Unrecognised obj {obj}')
    freq_str = ''
    grid_str = ''
    reduced_str = ''
    if code == 'euphonic':
        if from_fc:
            freq_str = '_fc'
        else:
            freq_str = '_phonons'
    if reduced:
        reduced_str = '_reduced'
    if obj == 'dw':
        grid_str = '_' + grid.replace(',', '')
    return f'{code}_{obj}{freq_str}{reduced_str}{grid_str}_{temperature}K.json'


def get_ab2tds_fpath(material: str, cut: str, temp: str) -> str:
    return os.path.join(
        get_dir(material, 'ab2tds', cut),
        f'alongthelineF_{temp}K.dat')


def get_oclimax_fpath(material: str, cut: str, in_file: bool = True,
                      temp: Optional[str] = None) -> str:
    if in_file:
        pattern = '*.params.copy'
    else:
        pattern = f'*_2Dmesh_scqw_{temp}K.csv'
    fname = find_file(get_dir(material, cut=cut, code='oclimax'),
                      pattern)
    return fname


def get_fc(material: str):
    cuts, grid, temps, code = get_material_info(material)
    if code == 'castep':
        pattern = '*.castep_bin'
    elif code == 'phonopy':
        pattern = '*[!m][!e][!s][!h].yaml'  # Do not match *mesh.yaml file
    else:
        raise ValueError('Unrecognised code {code}')
    fc_file = find_file(get_dir(material, code=code), pattern)
    print(f'Reading force constants from {fc_file}')
    if code == 'castep':
        fc = ForceConstants.from_castep(fc_file)
    else:
        fc = ForceConstants.from_phonopy(summary_name=fc_file)
    return fc

def get_phonon_modes(material: str, direc: str, root_pattern: str):
    _, _, _, code = get_material_info(material)
    if code == 'castep':
        pattern = f'{root_pattern}.phonon'
    elif code == 'phonopy':
        pattern = f'{root_pattern}.yaml'
    else:
        raise ValueError('Unrecognised code {code}')
    phon_file = find_file(get_dir(material, cut=direc, code=code), pattern)
    print(f'Reading phonon modes from {phon_file}')
    if code == 'castep':
        phon = QpointPhononModes.from_castep(phon_file)
    else:
        phon = QpointPhononModes.from_phonopy(phonon_name=phon_file)
    return phon

def get_qpts(material, cut):
    fname = get_euphonic_fpath(material, 'euphonic', 'sf', '300',
                               cut=cut, from_fc=True)
    sf =  StructureFactor.from_json_file(fname)
    return sf.qpts


def find_file(fdir, pattern):
    for f in os.listdir(fdir):
        if fnmatch.fnmatch(f, pattern):
            return os.path.join(fdir, f)
    raise Exception(f'{pattern} not found in {fdir}')


def plot_at_qpt(arrs, labels, x=None, x_title='', y_title='',
                title='', noshow=False, ptype=None, lc=line_colours,
                ls=line_styles, marks=markers, msizes=marker_sizes,
                plot_zeros=True, xlim=None, **legend_kwargs):
    fig, ax = plt.subplots()
    if x is None:
        x = np.arange(len(arr1))
    if ptype is None:
        ptype = 'line'
    if not plot_zeros:
        arrs_np = np.array(arrs)
        nonzero_idx = np.where(np.any(arrs_np > 0, axis=0))[0]
        arrs = arrs_np[:, nonzero_idx]
        x = x[nonzero_idx]
    for i, arr in enumerate(arrs):
        if ptype == 'line':
            ax.plot(x, arr, label=labels[i], color=lc[i%len(lc)], ls=ls[i%len(ls)])
        elif ptype == 'bar':
            ax.bar(x, arr, width=np.mean(np.diff(x)), align='edge',
                   label=labels[i], color=lc[i%len(lc)], alpha=0.5)
        elif ptype == 'scatter':
            ax.scatter(x, arr, label=labels[i], color=lc[i%len(lc)],
                       marker=marks[i%len(marks)], s=msizes[i%len(msizes)])
        else:
            raise ValueError(f'Unexpected plot type {pytype}')
    ax.ticklabel_format(axis='y', style='sci', scilimits=(-2, 3))
    ax.legend(**legend_kwargs)
    if xlim:
        ax.set_xlim(xlim)
    if x_title:
        ax.set_xlabel(x_title)
    if y_title:
        ax.set_ylabel(y_title)
    if title:
        fig.suptitle(title)
    if not noshow:
        fig.show()
    else:
        return fig


def get_scaling(arr1, arr2, rel_tol=None):
    with warnings.catch_warnings():
        warnings.simplefilter('ignore')
        scale = arr1/arr2
    idx, lim = get_idx_more_than_rel_tol(arr1, arr2, rel_tol=rel_tol)
    return np.mean(scale[idx])


def get_abs_error_and_idx(arr1, arr2):
    # Ignore zero entries - these will artificially reduce the abs error
    idx = np.where(np.logical_and(np.abs(arr1) > 0, np.abs(arr2) > 0))
    return np.abs(arr1 - arr2), idx


def get_idx_more_than_rel_tol(arr1, arr2, rel_tol=None):
    lim1 = get_lim(arr1, rel_tol)
    lim2 = get_lim(arr1, rel_tol)
    idx = np.where(np.logical_and(arr1 > lim1, arr2 > lim2))
    print(f'arr_shape: {arr1.shape} max1: {np.max(arr1)} lim1: {lim1} max2: {np.max(arr1)} lim2: {lim2} '
          f'n_nonzero_arr1: {len(np.where(arr1 > 0)[0])} n_used_entries: {len(idx[0])}')
    return idx, [lim1, lim2]


def get_lim(arr, rel_tol=None):
    if rel_tol is None:
        rel_tol = 1e-4
    lim = rel_tol*np.max(arr)
    return lim


def get_rel_error_and_idx(arr1, arr2, rel_tol=None):
    """
    Gets relative error of all array entries, and indices of entries
    that are below a certain relative tolerance so that these can be
    ignored - near-zero entries artificially cause a large relative
    error. We allow a divide by zero and therefore nan entries in
    rel_err as it is important to retain information on the original
    indexes, using np.where to only calculate the relative error on array
    entries above the threshold would reduce it to a 1d array and lose
    information on where the errors originally came from
    """
    with warnings.catch_warnings():
        warnings.simplefilter('ignore')
        rel_err = np.abs(arr1 - arr2)/arr1
    idx, lim = get_idx_more_than_rel_tol(arr1, arr2, rel_tol)
    return rel_err, idx, lim

def get_max_rel_error_idx(arr1, arr2, n=10, **kwargs):
    rel_err, idx, lim = get_rel_error_and_idx(arr1, arr2, **kwargs)
    rel_err_reduced = rel_err[idx]
    max_err_reduced_idx = np.argsort(-rel_err_reduced)
    # Now we can find which q-points/branches have the largest relative
    # errors in the original arrays (while disregarding almost-zero entries)
    max_err_idx = (idx[0][max_err_reduced_idx[:n]],
                   idx[1][max_err_reduced_idx[:n]])
    return max_err_idx
