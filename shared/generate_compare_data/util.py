import fnmatch
import os
import warnings
from typing import Optional

import numpy as np
import matplotlib.pyplot as plt

from euphonic import ForceConstants, StructureFactor


# Define here so they can be imported from elsewhere too,
# to allow consistent plot styles
line_colours = ['m', 'orange', 'tab:cyan']
line_styles = ['-', '-', '--']
markers = ['o', '+', 'x']
marker_sizes = [5**2, 7**2, 6**2]


def get_material_info(material, ab2tds=False):
    if ab2tds:
        temps = ['300']
    else:
        temps = ['5', '300']
    if material == 'quartz':
        cuts = ['2ph_m4_0_qe', '30L_qe_fine']
        grid = '5,5,4'
    elif material == 'lzo':
        cuts = ['kagome_qe', 'hh2_qe_fine']
        grid = '4,4,4'
    elif material == 'nb':
        cuts = ['110_qe', 'm110_qe']
        grid = '10,10,10'
    else:
        raise ValueErorr(f'Invalid material {material}')
    return cuts, grid, temps


def get_dir(material: str, code: Optional[str] = None,
            cut: Optional[str] = None) -> str:
    """
    Get directory containing files for that material, cut and code
    """
    path = os.path.join('..', '..', material)
    if cut is None:
        cut = 'shared'
    path = os.path.join(path, cut)
    if code is not None:
        path = os.path.join(path, code)
    return path


def get_euphonic_fpath(material: str, code: str, obj: str, temperature: str,
                       cut: Optional[str] = None, **fname_kwargs) -> str:
    """
    Get full path to euphonic .json output file for a particular
    material, code, and cut. See get_euphonic_fname for more arg details
    """
    return os.path.join(
        get_dir(material, code, cut=cut),
        get_euphonic_fname(obj, temperature, code=code, **fname_kwargs))


def get_euphonic_fname(
        obj: str, temperature: str, code: str = 'euphonic',
        from_fc: bool = False, grid: Optional[str] = None) -> str:
    """
    Generate Euphonic output .json filenames. These may be for Euphonic
    generated data, or Ab2tds/Oclimax data converted to Euphonic format

    Parameters
    ----------
    obj
        Type of data contained in the file, one of ['dw', 'sf', 'sqw']
        for DebyeWaller, StructureFactor and Spectrum2D containing a
        S(Q, w) map respectively
    temperature
        Temperature used to calculate obj
    code
        Which code obj was generated with, one of ['euphonic',
        'oclimax', 'ab2tds']
    from_fc
        Whether obj was generated by calculating phonon frequencies
        from force constants, or by reading precalculated
        frequencies (e.g. from a .phonon file). Only applicable if
        code='euphonic'
    grid
        Comma-separated MP grid that was used to generate obj e.g.
        '4,4,4'. Only applicable if obj='dw'
    """
    if not code in ['euphonic', 'ab2tds', 'oclimax']:
        raise ValueError(f'Unrecognised code {code}')
    if not obj in ['dw', 'sf', 'sqw']:
        raise ValueError(f'Unrecognised obj {obj}')
    freq_str = ''
    grid_str = ''
    if code == 'euphonic':
        if from_fc:
            freq_str = '_fc'
        else:
            freq_str = '_phonons'
    if obj == 'dw':
        grid_str = '_' + grid.replace(',', '')
    return f'{code}_{obj}{freq_str}{grid_str}_{temperature}K.json'


def get_ab2tds_fpath(material: str, cut: str, temp: str) -> str:
    return os.path.join(
        get_dir(material, 'ab2tds', cut),
        f'alongthelineF_{temp}K.dat')


def get_oclimax_fpath(material: str, cut: str, in_file: bool = True,
                      temp: Optional[str] = None) -> str:
    if in_file:
        pattern = '*.params.copy'
    else:
        pattern = f'*_2Dmesh_scqw_{temp}K.csv'
    fname = find_file(get_dir(material, cut=cut, code='oclimax'),
                      pattern)
    return fname


def get_fc(material: str):
    fc_file = find_file(get_dir(material, code='castep'), '*.castep_bin')
    print(f'Reading force constants from {fc_file}')
    return ForceConstants.from_castep(fc_file)


def get_qpts(material, cut):
    fname = get_euphonic_fpath(material, 'euphonic', 'sf', '300',
                               cut=cut, from_fc=True)
    sf =  StructureFactor.from_json_file(fname)
    return sf.qpts


def find_file(fdir, pattern):
    for f in os.listdir(fdir):
        if fnmatch.fnmatch(f, pattern):
            return os.path.join(fdir, f)
    raise Exception(f'{pattern} not found in {fdir}')


def plot_at_qpt(arrs, labels, x=None, x_title='', y_title='',
                title='', noshow=False, ptype=None, lc=line_colours,
                ls=line_styles, marks=markers, msizes=marker_sizes,
                plot_zeros=True, xlim=None, **legend_kwargs):
    fig, ax = plt.subplots()
    if x is None:
        x = np.arange(len(arr1))
    if ptype is None:
        ptype = 'line'
    if not plot_zeros:
        arrs_np = np.array(arrs)
        nonzero_idx = np.where(np.any(arrs_np > 0, axis=0))[0]
        arrs = arrs_np[:, nonzero_idx]
        x = x[nonzero_idx]
    for i, arr in enumerate(arrs):
        if ptype == 'line':
            ax.plot(x, arr, label=labels[i], color=lc[i%len(lc)], ls=ls[i%len(ls)])
        elif ptype == 'bar':
            ax.bar(x, arr, width=np.mean(np.diff(x)), align='edge',
                   label=labels[i], color=lc[i%len(lc)], alpha=0.5)
        elif ptype == 'scatter':
            ax.scatter(x, arr, label=labels[i], color=lc[i%len(lc)],
                       marker=marks[i%len(marks)], s=msizes[i%len(msizes)])
        else:
            raise ValueError(f'Unexpected plot type {pytype}')
    ax.ticklabel_format(axis='y', style='sci', scilimits=(-2, 3))
    ax.legend(**legend_kwargs)
    if xlim:
        ax.set_xlim(xlim)
    if x_title:
        ax.set_xlabel(x_title)
    if y_title:
        ax.set_ylabel(y_title)
    if title:
        fig.suptitle(title)
    if not noshow:
        fig.show()
    else:
        return fig


def get_scaling(arr1, arr2, rel_tol=None):
    with warnings.catch_warnings():
        warnings.simplefilter('ignore')
        scale = arr1/arr2
    idx, lim = get_idx_more_than_rel_tol(arr2, rel_tol)
    return np.mean(scale[idx])


def get_abs_error_and_idx(arr1, arr2):
    # Ignore zero entries - these will artificially reduce the abs error
    idx = np.where(np.logical_and(np.abs(arr1) > 0, np.abs(arr2) > 0))
    return np.abs(arr1 - arr2), idx


def get_idx_more_than_rel_tol(arr, rel_tol=None):
    lim = get_lim(arr, rel_tol)
    idx = np.where(arr > lim)
    print(f'arr_shape: {arr.shape} max: {np.max(arr)} lim: {lim} '
          f'n_nonzero: {len(np.where(arr > 0)[0])} n_used_entries: {len(idx[0])}')
    return idx, lim


def get_lim(arr, rel_tol=None):
    if rel_tol is None:
        rel_tol = 1e-4
    lim = rel_tol*np.max(arr)
    return lim


def get_rel_error_and_idx(arr1, arr2, rel_tol=None):
    """
    Gets relative error of all array entries, and indices of entries
    that are below a certain relative tolerance so that these can be
    ignored - near-zero entries artificially cause a large relative
    error. We allow a divide by zero and therefore nan entries in
    rel_err as it is important to retain information on the original
    indexes, using np.where to only calculate the relative error on array
    entries above the threshold would reduce it to a 1d array and lose
    information on where the errors originally came from
    """
    with warnings.catch_warnings():
        warnings.simplefilter('ignore')
        rel_err = np.abs(arr1 - arr2)/arr1
    idx, lim = get_idx_more_than_rel_tol(arr1, rel_tol)
    return rel_err, idx, lim

def get_max_rel_error_idx(arr1, arr2, n=10, **kwargs):
    rel_err, idx, lim = get_rel_error_and_idx(arr1, arr2, **kwargs)
    rel_err_reduced = rel_err[idx]
    max_err_reduced_idx = np.argsort(-rel_err_reduced)
    # Now we can find which q-points/branches have the largest relative
    # errors in the original arrays (while disregarding almost-zero entries)
    max_err_idx = (idx[0][max_err_reduced_idx[:n]],
                   idx[1][max_err_reduced_idx[:n]])
    return max_err_idx
